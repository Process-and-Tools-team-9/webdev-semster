| Criteria                    | Excellent (9-10)                                             | Good (7-8.5)                                                    | Fair (5-6.5)                                                    | Poor (3-4.5)                                                    | Incomplete (0-2.5)                                                    |
|-----------------------------|----------------------------------------------------------------|-----------------------------------------------------------------|-----------------------------------------------------------------|-----------------------------------------------------------------|-----------------------------------------------------------------------|
| **CLO1: Endpoint**  | | | | | |
| Endpoint Implementation, request/ response handling    | All endpoints are correctly implemented, inline documented, and adhere to RESTful principles. They effectively handle various HTTP methods and provide appropriate response including status codes. | Most endpoints are correctly implemented and adhere to RESTful principles, with a few minor endpoints are incomplete, or some request / responses might not be handled properly.| Some endpoints are correctly implemented but lack documentation or adherence to RESTful principles. The core functionality of application is still there with peripheral cases are missing or incomplete. | Few endpoints are correctly implemented, poorly documented, or do not adhere to RESTful principles. They handle HTTP methods and resource representations inadequately, causing issues. | Most endpoints are missing, incorrectly implemented, undocumented, or fail to adhere to RESTful principles, rendering the API unusable. |
| **CLO2: dependency injection**  | | | | | |
| Dependency Injection and Data Persistance  | Dependency injection is correctly implemented throughout the application, promoting modularity, and maintainability. The data is made persistant, and crud operations are working properly. | Dependency injection is mostly correct and functional but may have minor issues or inconsistencies. Data is persistant with most of the crud operations working properly | Dependency injection is present but has issues in some modules, The crud operation on data have minor issues. | Dependency injection is poor, or data is not made consistant | Dependency injection is severely flawed, and/or data is not being made persistant. It may not function as intended or disrupt application functionality. |
| **CLO3: middleware/ filters**  | | | | | |
| Middleware Implementation | Demonstrates proficiency in implementing middleware and filters to secure API endpoints and enhance security measures. | Middleware implementation is mostly correct and functional but may have minor issues or inconsistencies. It generally enhances API security but may lack full integration or adherence to best practices. | Middleware implementation has noticeable issues, such as inefficiencies, inconsistencies, or incomplete functionality. It may not fully enhance API security or integrate well with the application architecture. | Middleware implementation is poor, causing security vulnerabilities or insufficient protection of API endpoints. It may lack key functionality or proper integration with other components. | Middleware implementation is severely flawed, leading to frequent security breaches or inadequate protection of API endpoints. It may not function as intended or disrupt application security. |
| **CLO4: FP/TS**  | | | | | |
|Funcational Programming | The solution is a well-designed application that effectively applies complex functional programming aspects. It follows pure functional programming principles meticulously. The codebase is clean, concise, and elegantly designed | The solution predominantly adheres to functional programming principles, with most aspects correctly applied. While there may be minor flaws or inconsistencies, the codebase is generally well-structured and follows functional programming practices effectively. | The solution follows functional programming principles to some extent but lacks consistency or clarity in its implementation. While functional aspects are present, they may be poorly integrated or applied inconsistently throughout the codebase.| The solution deviates significantly from functional programming principles. Functional aspects are either absent or poorly implemented, The application design may be cluttered, disorganized, or overly reliant on mutable state and side effects. | The solution is incomplete or severely flawed, with little evidence of functional programming principles being applied. It may rely heavily on imperative programming techniques, resulting in an ineffective or non-functional application. |
| **CLO5: front-end components**  | | | | | |
| User interfaces using React.js library in TypeScript, applying component-based architecture  | The solution is a well-designed application that effectively applies complex functional programming aspects. It follows pure functional programming principles meticulously, demonstrating mastery of advanced concepts such as pure functions, immutability, higher-order functions, function composition, polymorphism, recursion, currying, and closures. The codebase is clean, concise, and elegantly designed, with minimal mixing of functional and imperative programming paradigms. | The solution predominantly adheres to functional programming principles, with most aspects correctly applied. It demonstrates a solid understanding of functional programming concepts, including pure functions, immutability, higher-order functions, and function composition. While there may be minor flaws or inconsistencies, the codebase is generally well-structured and follows functional programming practices effectively. | The solution follows functional programming principles to some extent but lacks consistency or clarity in its implementation. While functional aspects are present, they may be poorly integrated or applied inconsistently throughout the codebase. The application design may be somewhat convoluted or overly complex, detracting from the overall quality of the solution. | The solution deviates significantly from functional programming principles, with a majority of the codebase following imperative programming paradigms. Functional aspects are either absent or poorly implemented, leading to a codebase that is difficult to understand, maintain, or extend. The application design may be cluttered, disorganized, or overly reliant on mutable state and side effects. | The solution is incomplete or severely flawed, with little evidence of functional programming principles being applied. It may rely heavily on imperative programming techniques, resulting in an ineffective or non-functional application. The codebase lacks coherence, structure, or adherence to any discernible programming paradigm. |
| **CLO6: data exchange**  | | | | | |
| Communication between front-end React components and back-end  | The solution demonstrates exceptional proficiency in designing and implementing effective communication between front-end React components and back-end .NET Core Web APIs. It uses asynchronous HTTP requests (fetch) and adheres closely to RESTful API conventions, ensuring efficient data exchange, error handling, and synchronization. The communication process is robust, reliable, and follows best practices for client-server communication. | The solution exhibits solid proficiency in designing and implementing effective communication between front-end React components and back-end .NET Core Web APIs. It utilizes asynchronous HTTP requests (fetch) to exchange data and follows RESTful API conventions for consistency and clarity. While there may be minor issues or inconsistencies, the communication process is generally well-implemented and adheres to best practices. | The solution demonstrates basic proficiency in designing and implementing communication between front-end React components and back-end .NET Core Web APIs. It uses asynchronous HTTP requests (fetch) and attempts to adhere to RESTful API conventions, but there may be noticeable issues with efficiency, error handling, or synchronization. The communication process may lack clarity or consistency in implementation. | The solution lacks proficiency in designing and implementing communication between front-end React components and back-end .NET Core Web APIs. It may deviate significantly from RESTful API conventions or fail to handle asynchronous requests effectively. The communication process may be inefficient, error-prone, or poorly synchronized, leading to suboptimal data exchange and integration between client and server. | The solution is incomplete or severely flawed, with little evidence of proficiency in designing and implementing communication between front-end React components and back-end .NET Core Web APIs. It may lack essential components or fail to establish functional communication channels required for effective data exchange. The integration between client and server may be incomplete, non-functional, or poorly implemented. |